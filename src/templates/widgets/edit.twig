{% extends "_layouts/cp" %}
{% import "_includes/forms" as forms %}

{% set title = isNew ? "New Widget Config"|t('search-manager') : widgetConfig.name %}
{% set fullPageForm = true %}
{% set selectedSubnavItem = 'widgets' %}
{% set saveShortcutRedirect = cpUrl('search-manager/widgets/edit/{id}') %}
{% set retainScrollOnSaveShortcut = true %}

{% set crumbs = [
    { label: searchHelper.fullName, url: url('search-manager') },
    { label: 'Widgets'|t('search-manager'), url: url('search-manager/widgets') },
    { label: isNew ? 'New Widget Config'|t('search-manager') : widgetConfig.name }
] %}

{# Set up tabs #}
{% set tabs = {
    settings: {
        label: 'Settings'|t('search-manager'),
        url: '#settings',
    },
    behavior: {
        label: 'Behavior'|t('search-manager'),
        url: '#behavior',
    },
    appearance: {
        label: 'Appearance'|t('search-manager'),
        url: '#appearance',
    },
} %}

{% block actionButton %}
	<div class="btngroup submit">
		<button type="submit" class="btn submit">{{ "Save"|t('app') }}</button>
		<button type="button" class="btn submit menubtn"></button>
		<div class="menu">
			<ul role="listbox">
				<li>
					<a class="formsubmit" role="option" tabindex="0" data-redirect="{{ cpUrl('search-manager/widgets/edit/{id}')|hash }}">
						<span class="label">{{ 'Save and continue editing'|t('app') }}</span>
						<span class="shortcut" id="save-shortcut"></span>
					</a>
				</li>
			</ul>
		</div>
	</div>
	{% if not isNew and currentUser.can('searchManager:manageSettings') and not widgetConfig.isDefault %}
		<button type="button" id="action-btn" class="btn menubtn action-btn hairline-dark m" title="{{ 'Actions'|t('app') }}" aria-controls="action-menu" aria-label="{{ 'Actions'|t('app') }}" data-disclosure-trigger="true" aria-expanded="false"></button>
		<div id="action-menu" class="menu menu--disclosure">
			<ul>
				<li>
					<button class="menu-item error formsubmit" data-destructive data-action="search-manager/widgets/delete" data-params='{"configId":{{ widgetConfig.id }}}' data-confirm="{{ 'Are you sure you want to delete this widget config?'|t('search-manager') }}" data-redirect="{{ 'search-manager/widgets'|hash }}" data-headers='{"Accept":"application/json"}'>
						<span class="icon">{{ svg('@app/icons/trash.svg') }}</span>
						<span class="menu-item-label">{{ "Delete"|t('app') }}</span>
					</button>
				</li>
			</ul>
		</div>
	{% endif %}
{% endblock %}

{% block content %}
	<input type="hidden" name="action" value="search-manager/widgets/save">
	<input type="hidden" name="redirect" value="{{ 'search-manager/widgets'|hash }}">
	{% if not isNew %}
		<input type="hidden" name="configId" value="{{ widgetConfig.id }}">
	{% endif %}
	{{ csrfInput() }}

	{# Settings Tab #}
	<div id="settings">
		{% include "search-manager/widgets/_partials/settings" with {
			widgetConfig: widgetConfig,
			indices: indices,
			isNew: isNew
		} %}
	</div>

	{# Behavior Tab #}
	<div id="behavior" class="hidden">
		{% include "search-manager/widgets/_partials/behavior" with {
			widgetConfig: widgetConfig
		} %}
	</div>

	{# Appearance Tab #}
	<div id="appearance" class="hidden">
		{% include "search-manager/widgets/_partials/appearance" with {
			widgetConfig: widgetConfig
		} %}
	</div>
{% endblock %}

{% block details %}
	<div class="meta">
		{{ forms.lightswitchField({
			label: 'Enabled'|t('search-manager'),
			id: 'enabled',
			name: 'enabled',
			on: widgetConfig.enabled ?? true
		}) }}

		{% if widgetConfig.isDefault %}
			{# Default config - show disabled switch with explanation #}
			{{ forms.lightswitchField({
				label: 'Default'|t('search-manager'),
				instructions: 'This is the default config. To change, set another config as default first.',
				id: 'isDefault',
				name: 'isDefault',
				on: true,
				disabled: true
			}) }}
			{# Hidden field to preserve the value since disabled inputs don't submit #}
			<input type="hidden" name="isDefault" value="1">
		{% else %}
			{{ forms.lightswitchField({
				label: 'Default'|t('search-manager'),
				instructions: 'Use as default when no config handle is specified',
				id: 'isDefault',
				name: 'isDefault',
				on: false
			}) }}
		{% endif %}
	</div>

	{# Widget Preview - only visible on Appearance tab #}
	<div id="widget-preview-wrapper" style="display: none;">
		{% include "search-manager/widgets/_partials/preview" with {
			widgetConfig: widgetConfig
		} %}
	</div>

	{% if not isNew %}
		<fieldset>
			<dl class="meta read-only">
				<div class="data">
					<dt class="heading">{{ 'Handle'|t('search-manager') }}</dt>
					<dd class="value">
						<code>{{ widgetConfig.handle }}</code>
					</dd>
				</div>
				<div class="data">
					<dt class="heading">{{ 'Status'|t('search-manager') }}</dt>
					<dd class="value">
						<span class="status {{ widgetConfig.enabled ? 'live' : 'disabled' }}"></span>
						<span>{{ widgetConfig.enabled ? 'Live'|t('search-manager') : 'Disabled'|t('search-manager') }}</span>
					</dd>
				</div>
			</dl>
		</fieldset>

		<fieldset>
			<legend class="h6">{{ 'Usage in Templates'|t('search-manager') }}</legend>
			<div class="meta read-only">
				<div class="data">
					<dd class="value" style="padding: 0;">
						<div style="background: #f3f7fc; padding: 10px; border-radius: 4px; font-family: monospace; font-size: 11px; line-height: 1.5;">
							<code style="display: block; white-space: pre-wrap; word-break: break-all;">{% verbatim %}{% include 'search-manager/_widget/search' with {
    config: '{% endverbatim %}{{ widgetConfig.handle }}{% verbatim %}',
} %}{% endverbatim %}</code>
						</div>
					</dd>
				</div>
			</div>
		</fieldset>
	{% endif %}
{% endblock %}

{% js %}
// Set platform-specific keyboard shortcut
const isMac = navigator.platform.toUpperCase().indexOf('MAC') >= 0;
const saveShortcut = document.getElementById('save-shortcut');
if (saveShortcut) {
	saveShortcut.textContent = isMac ? 'âŒ˜S' : 'Ctrl+S';
}

// Handle auto-generation from name
(function() {
	const nameInput = document.getElementById('name');
	const handleInput = document.getElementById('handle');
	const isNew = {{ isNew ? 'true' : 'false' }};
	let handleModifiedManually = !isNew; // Don't auto-update existing handles

	// Convert name to handle format
	function nameToHandle(name) {
		return name
			.toLowerCase()
			.replace(/[^a-z0-9]+/g, '-')
			.replace(/^-+|-+$/g, '');
	}

	// Only auto-generate handle for new configs
	if (isNew && nameInput && handleInput) {
		nameInput.addEventListener('input', function() {
			if (!handleModifiedManually) {
				handleInput.value = nameToHandle(this.value);
			}
		});

		// If user manually edits handle, stop auto-generation
		handleInput.addEventListener('input', function() {
			handleModifiedManually = true;
		});
	}
})();

// Show preview only on Appearance tab
(function() {
	const previewWrapper = document.getElementById('widget-preview-wrapper');
	if (!previewWrapper) return;

	function updatePreviewVisibility() {
		const hash = window.location.hash || '#settings';
		previewWrapper.style.display = hash === '#appearance' ? 'block' : 'none';
	}

	// Check on load
	updatePreviewVisibility();

	// Listen for hash changes (tab switches)
	window.addEventListener('hashchange', updatePreviewVisibility);

	// Also listen for Craft's tab clicks
	document.querySelectorAll('#tabs a').forEach(function(tab) {
		tab.addEventListener('click', function() {
			setTimeout(updatePreviewVisibility, 10);
		});
	});
})();

// Widget Preview functionality
(function() {
	const lightPreview = document.querySelector('.widget-preview-light');
	const darkPreview = document.querySelector('.widget-preview-dark');
	if (!lightPreview || !darkPreview) return;

	// Light/Dark mode toggle
	const toggleButtons = document.querySelectorAll('.widget-preview-toggle .btn');
	toggleButtons.forEach(function(btn) {
		btn.addEventListener('click', function() {
			const mode = this.getAttribute('data-preview-mode');
			lightPreview.style.display = mode === 'light' ? 'block' : 'none';
			darkPreview.style.display = mode === 'dark' ? 'block' : 'none';
			toggleButtons.forEach(function(b) {
				b.setAttribute('aria-pressed', b === btn ? 'true' : 'false');
				b.classList.toggle('secondary', b !== btn);
			});
		});
	});

	// Preview update configuration
	// Maps form input names to preview element updates
	const previewConfig = {
		// Modal
		'settings[styles][modalBg]': [
			{ container: lightPreview, selector: '.preview-modal', prop: 'backgroundColor' }
		],
		'settings[styles][modalBgDark]': [
			{ container: darkPreview, selector: '.preview-modal', prop: 'backgroundColor' }
		],
		'settings[styles][modalBorderColor]': [
			{ container: lightPreview, selector: '.preview-modal', prop: 'borderColor' }
		],
		'settings[styles][modalBorderColorDark]': [
			{ container: darkPreview, selector: '.preview-modal', prop: 'borderColor' }
		],
		'settings[styles][modalBorderRadius]': [
			{ container: lightPreview, selector: '.preview-modal', prop: 'borderRadius', unit: 'px' },
			{ container: darkPreview, selector: '.preview-modal', prop: 'borderRadius', unit: 'px' }
		],
		'settings[styles][modalBorderWidth]': [
			{ container: lightPreview, selector: '.preview-modal', prop: 'borderWidth', unit: 'px' },
			{ container: darkPreview, selector: '.preview-modal', prop: 'borderWidth', unit: 'px' }
		],
		'settings[styles][modalShadow]': [
			{ container: lightPreview, selector: '.preview-modal', prop: 'boxShadow' },
			{ container: darkPreview, selector: '.preview-modal', prop: 'boxShadow' }
		],

		// Input
		'settings[styles][inputBg]': [
			{ container: lightPreview, selector: '.preview-input', prop: 'backgroundColor' }
		],
		'settings[styles][inputBgDark]': [
			{ container: darkPreview, selector: '.preview-input', prop: 'backgroundColor' }
		],
		'settings[styles][inputTextColor]': [
			{ container: lightPreview, selector: '.preview-search-icon', prop: 'stroke' }
		],
		'settings[styles][inputTextColorDark]': [
			{ container: darkPreview, selector: '.preview-search-icon', prop: 'stroke' }
		],
		'settings[styles][inputPlaceholderColor]': [
			{ container: lightPreview, selector: '.preview-placeholder', prop: 'color' }
		],
		'settings[styles][inputPlaceholderColorDark]': [
			{ container: darkPreview, selector: '.preview-placeholder', prop: 'color' }
		],
		'settings[styles][inputBorderColor]': [
			{ container: lightPreview, selector: '.preview-input', prop: 'borderColor' }
		],
		'settings[styles][inputBorderColorDark]': [
			{ container: darkPreview, selector: '.preview-input', prop: 'borderColor' }
		],
		'settings[styles][inputFontSize]': [
			{ container: lightPreview, selector: '.preview-placeholder', prop: 'fontSize', unit: 'px' },
			{ container: darkPreview, selector: '.preview-placeholder', prop: 'fontSize', unit: 'px' }
		],

		// Results
		'settings[styles][resultTextColor]': [
			{ container: lightPreview, selector: '.preview-result-title', prop: 'color', all: true }
		],
		'settings[styles][resultTextColorDark]': [
			{ container: darkPreview, selector: '.preview-result-title', prop: 'color', all: true }
		],
		'settings[styles][resultDescColor]': [
			{ container: lightPreview, selector: '.preview-result-desc', prop: 'color', all: true }
		],
		'settings[styles][resultDescColorDark]': [
			{ container: darkPreview, selector: '.preview-result-desc', prop: 'color', all: true }
		],
		'settings[styles][resultHoverBg]': [
			{ container: lightPreview, selector: '.preview-result', prop: 'backgroundColor', index: 2 }
		],
		'settings[styles][resultHoverBgDark]': [
			{ container: darkPreview, selector: '.preview-result', prop: 'backgroundColor', index: 2 }
		],
		'settings[styles][resultActiveBg]': [
			{ container: lightPreview, selector: '.preview-result', prop: 'backgroundColor', index: 1 }
		],
		'settings[styles][resultActiveBgDark]': [
			{ container: darkPreview, selector: '.preview-result', prop: 'backgroundColor', index: 1 }
		],
		'settings[styles][resultBorderRadius]': [
			{ container: lightPreview, selector: '.preview-result', prop: 'borderRadius', unit: 'px', all: true },
			{ container: darkPreview, selector: '.preview-result', prop: 'borderRadius', unit: 'px', all: true }
		],

		// Highlighting
		'settings[highlighting][bgLight]': [
			{ container: lightPreview, selector: '.preview-result mark', prop: 'backgroundColor' }
		],
		'settings[highlighting][colorLight]': [
			{ container: lightPreview, selector: '.preview-result mark', prop: 'color' }
		],
		'settings[highlighting][bgDark]': [
			{ container: darkPreview, selector: '.preview-result mark', prop: 'backgroundColor' }
		],
		'settings[highlighting][colorDark]': [
			{ container: darkPreview, selector: '.preview-result mark', prop: 'color' }
		],

		// Trigger
		'settings[styles][triggerBg]': [
			{ container: lightPreview, selector: '.preview-trigger', prop: 'backgroundColor' }
		],
		'settings[styles][triggerBgDark]': [
			{ container: darkPreview, selector: '.preview-trigger', prop: 'backgroundColor' }
		],
		'settings[styles][triggerTextColor]': [
			{ container: lightPreview, selector: '.preview-trigger', prop: 'color' }
		],
		'settings[styles][triggerTextColorDark]': [
			{ container: darkPreview, selector: '.preview-trigger', prop: 'color' }
		],
		'settings[styles][triggerBorderColor]': [
			{ container: lightPreview, selector: '.preview-trigger', prop: 'borderColor' }
		],
		'settings[styles][triggerBorderColorDark]': [
			{ container: darkPreview, selector: '.preview-trigger', prop: 'borderColor' }
		],
		'settings[styles][triggerBorderRadius]': [
			{ container: lightPreview, selector: '.preview-trigger', prop: 'borderRadius', unit: 'px' },
			{ container: darkPreview, selector: '.preview-trigger', prop: 'borderRadius', unit: 'px' }
		],
		'settings[styles][triggerBorderWidth]': [
			{ container: lightPreview, selector: '.preview-trigger', prop: 'borderWidth', unit: 'px' },
			{ container: darkPreview, selector: '.preview-trigger', prop: 'borderWidth', unit: 'px' }
		],
		'settings[styles][triggerPaddingX]': [
			{ container: lightPreview, selector: '.preview-trigger', prop: 'paddingLeft', unit: 'px' },
			{ container: lightPreview, selector: '.preview-trigger', prop: 'paddingRight', unit: 'px' },
			{ container: darkPreview, selector: '.preview-trigger', prop: 'paddingLeft', unit: 'px' },
			{ container: darkPreview, selector: '.preview-trigger', prop: 'paddingRight', unit: 'px' }
		],
		'settings[styles][triggerPaddingY]': [
			{ container: lightPreview, selector: '.preview-trigger', prop: 'paddingTop', unit: 'px' },
			{ container: lightPreview, selector: '.preview-trigger', prop: 'paddingBottom', unit: 'px' },
			{ container: darkPreview, selector: '.preview-trigger', prop: 'paddingTop', unit: 'px' },
			{ container: darkPreview, selector: '.preview-trigger', prop: 'paddingBottom', unit: 'px' }
		],
		'settings[styles][triggerFontSize]': [
			{ container: lightPreview, selector: '.preview-trigger', prop: 'fontSize', unit: 'px' },
			{ container: darkPreview, selector: '.preview-trigger', prop: 'fontSize', unit: 'px' }
		],

		// Keyboard badge
		'settings[styles][kbdBg]': [
			{ container: lightPreview, selector: '.preview-kbd', prop: 'backgroundColor' },
			{ container: lightPreview, selector: '.preview-trigger-kbd', prop: 'backgroundColor' }
		],
		'settings[styles][kbdBgDark]': [
			{ container: darkPreview, selector: '.preview-kbd', prop: 'backgroundColor' },
			{ container: darkPreview, selector: '.preview-trigger-kbd', prop: 'backgroundColor' }
		],
		'settings[styles][kbdTextColor]': [
			{ container: lightPreview, selector: '.preview-kbd', prop: 'color' },
			{ container: lightPreview, selector: '.preview-trigger-kbd', prop: 'color' }
		],
		'settings[styles][kbdTextColorDark]': [
			{ container: darkPreview, selector: '.preview-kbd', prop: 'color' },
			{ container: darkPreview, selector: '.preview-trigger-kbd', prop: 'color' }
		],
		'settings[styles][kbdBorderRadius]': [
			{ container: lightPreview, selector: '.preview-kbd', prop: 'borderRadius', unit: 'px' },
			{ container: lightPreview, selector: '.preview-trigger-kbd', prop: 'borderRadius', unit: 'px' },
			{ container: darkPreview, selector: '.preview-kbd', prop: 'borderRadius', unit: 'px' },
			{ container: darkPreview, selector: '.preview-trigger-kbd', prop: 'borderRadius', unit: 'px' }
		]
	};

	// Check if value is a hex color (6 hex characters without #)
	function isHexColor(value) {
		return /^[0-9a-fA-F]{6}$/.test(value);
	}

	// Apply a value to preview elements
	function applyToPreview(inputName, value) {
		const config = previewConfig[inputName];
		if (!config || !value) return;

		config.forEach(function(rule) {
			var finalValue = value;

			// Add # prefix for hex colors (Craft strips it in color fields)
			if (isHexColor(value)) {
				finalValue = '#' + value;
			}

			// Add unit suffix if specified (for dimensions like px)
			if (rule.unit) {
				finalValue = value + rule.unit;
			}

			if (rule.index !== undefined) {
				// Specific element by index
				const elements = rule.container.querySelectorAll(rule.selector);
				if (elements[rule.index]) {
					elements[rule.index].style[rule.prop] = finalValue;
				}
			} else if (rule.all) {
				// All matching elements
				rule.container.querySelectorAll(rule.selector).forEach(function(el) {
					el.style[rule.prop] = finalValue;
				});
			} else {
				// First matching element
				const el = rule.container.querySelector(rule.selector);
				if (el) {
					el.style[rule.prop] = finalValue;
				}
			}
		});
	}

	// Store last known values
	const lastValues = {};

	// Scan all form inputs and update preview
	function syncPreview() {
		document.querySelectorAll('input[name^="settings["]').forEach(function(input) {
			const name = input.name;
			const value = input.value;

			if (value && value !== lastValues[name]) {
				lastValues[name] = value;
				applyToPreview(name, value);
			}
		});
	}

	// Initial sync
	syncPreview();

	// Listen for input events on the form
	document.querySelector('form').addEventListener('input', function(e) {
		if (e.target.name && e.target.name.startsWith('settings[')) {
			const name = e.target.name;
			const value = e.target.value;
			if (value !== lastValues[name]) {
				lastValues[name] = value;
				applyToPreview(name, value);
			}
		}
	});

	// Poll for changes (catches color picker updates)
	setInterval(syncPreview, 100);
})();
{% endjs %}
